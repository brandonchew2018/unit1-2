Math operators: #math, #operators, #built-in

+ adds; x+y returns math value x+y
- subtracts; x-y returns math value x-y
* multiplies; x*y returns math value x*y
/ divides; x/y returns math value x/y
// divides as an int; x//y returns math value x/y, but casted as an int(floored)
% modulates; x%y returns math value x%y (remainder of x/y)
** exponentiates; x**y returns math value of x^y(not the bitwise or function)
abs(x); returns absolute value of x
range(x), generates x numbers, from 0 to x-1
range(x,y) generates numbers x to y-1
range(x,y,z) generates numbers from x to y-1, with step size of z

Math library: #math
round(float x); rounds numerically
ceil(float x); returns smallest integer greater than x
sqrt(float or int x); returns the squre root of x
floor(float x); returns first less x
log(float or int x); returns ln(x)
log(float or int x, float or int a); returns log base x of a 
pi; it's pi
e; Euler's number
sin(x); radians(for all trig)
cos(x);
tan(x);
asin(x);

Importing: #import
import _library; imports library
from _library import _method/object ;imports only one method or object from library, acts as though static

Printing: #print
print(string); prints out string on its own line
print(string1,string2,string3...) prints out each string on the same line, with a space between each item
print(string1+string2+string3...) prints out all strings on the same line, without spaces in between, but '' must be used instead of ""
print(string1, ..., sep="string2", end="string3"); prints string1 and on, delimiting with string2 and ending with string3 (will not print on its own line if end != \n)


Commenting: #comment
# makes a "till end of line" comment; #comment

Logical Operators: #logic, #logical, #operators
a < b ; less than
a > b ; greater than
a <= b ; less than or equal to
a >= b ; greater than or equal to
a == b ; equal to
a != b ; not equal to
and; &&
or; ||
not; use to negate boolean expressions

Input: #input
input() returns typed string; even if it starts as a double

Casting: #casting
int(string str); casts string as an int
str(any number format)
bool(string or number); casts empty strings and 0 as False and any full strings or the number 1 as True (booleans in python are capitalized)

variables can be assigned as in "a, b = 0, 1"
Conditionals: #if, #else, #while, #for
if(boolean or boolean expression):
    code1
elif(boolean or boolean expression):
    code2
else:
    code3
    
; executes code based on conditions calling true or false (will not cascade)

for x in (range (y,z), string, list, collection, collection of collections, etc.):
    code 1
    
; executes code 1 based on iterations of conditional( 1 at a time) note: lists can be differnt types

while(condition x):
    code1
else:
    code2
; executes code1 while x returns true. If it returns false, code2 runs once. If the while loops breaks before x returns false, code2 will not run
;if continue is met, the remaining instructions will be skipped and the next iteration started


Strings: #strings
str[int x: int y] ; returns substring from x to y, not including y (if you use a negative index, it will start from the end of the string)
str[int x] ; returns just the character at the index
str[int x : int y : int z] returns characters from indecies x to y, using a step size of z
str[:int x] returns the string ommitting characters at index x and after
str[int x:] returns the string ommitting characters before index x
str x.find(str y) returns the index of the first instance of y in x, or -1 if there is not instance of y in x
str x.rfind(str y) returns the index of the last instance of y in x, or -1 if there is not instance of y in x
str x.find(str y, int l, int r) returns method return of x[l:r].find(y), as if the substring still uses the absolute indexes
str s.replace(str x, str y) replaces all occurrences of a x with y
str s.replace(str x, str y, int z) replaces the first z occurrences of a x with y
str s.count(str x) returns number of occurrences of x in s, and non-overlapping occurances do not count
str s.count(str x, int l, int r) returns numner of occurances of x in s[l:r], and non-overlapping occurances do not count
len(any type x) returns number of characters in x

